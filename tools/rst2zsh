#! /bin/zsh -f
# ./sections/rst2zsh/setup.rst:27
setopt err_exit no_unset warn_create_global
# ./sections/rst2zsh/setup.rst:31
zmodload -F zsh/zutil +b:zparseopts
# ./sections/rst2zsh/block_definition.rst:18
start_block='^(::|\.\. code:: zsh|[^\. ][^\.].*::)$'
# ./sections/rst2zsh/parse_function.rst:12
parse() {
    local input=$1 output=$2
# ./sections/rst2zsh/parse_function.rst:18
local _RST2HTML_recursing=${_RST2HTML_recursing:-0}
# ./sections/rst2zsh/parse_function.rst:22
(( $_RST2HTML_recursing )) || : >| $output
# ./sections/rst2zsh/parse_function.rst:26
integer in_block=0 in_toctree=0
# ./sections/rst2zsh/parse_function.rst:31
integer line_nr=1
# ./sections/rst2zsh/parse_function.rst:35
local indent_prefix=""
local line match mbegin mend
while IFS='' read -r line; do
    (( line_nr++ ))
    if [[ $line =~ '^.. include:: (.*)' ]] {
        includes+=(${input:h}/$match)
        _RST2HTML_recursing=1 parse ${input:h}/$match $output
    } elif [[ $line =~ '^.. toctree::' ]] {
        in_toctree=1
# ./sections/rst2zsh/parse_function.rst:47
} elif (( $in_toctree )) && [[ $line =~ '^[[:space:]]+([^ :].*)' ]] {
    includes+=(${input:h}/$match[1].rst)
    _RST2HTML_recursing=1 parse ${input:h}/$match[1].rst $output
} elif [[ $line =~ $start_block ]] {
    (( ++block_count))
    in_block=1
    in_toctree=0
# ./sections/rst2zsh/parse_function.rst:57
indent_prefix=""
# ./sections/rst2zsh/parse_function.rst:64
if [[ -s $output ]] {
    echo "# $input:$line_nr" >> $output
}
            } elif [[ $line =~ '^[^ ]' ]] {
# ./sections/rst2zsh/parse_function.rst:71
in_block=0
in_toctree=0
            } elif (( $in_block )) && [[ -n $line ]] {
if [[ -z $indent_prefix ]] {
# ./sections/rst2zsh/parse_function.rst:78
[[ $line =~ '^([[:space:]]+)' ]] && indent_prefix=$match[1]
                }
# ./sections/rst2zsh/parse_function.rst:83
echo -E "${line#$indent_prefix}" >> $output
            }
        done < $input
# ./sections/rst2zsh/parse_function.rst:90
if ! (( $_RST2HTML_recursing )) {
    if [[ ! -s $output ]] {
        print -u2 "Warning: No Zsh code blocks found in '$input'"
    } else {
        print -u2 "Extracted $block_count Zsh code blocks to '$output'"
    }
}
    }
# ./sections/rst2zsh/main_logic.rst:7
typeset -A args
zparseopts -D -K -E -A args d: h
if [[ -n ${args[(I)-h]} ]] {
    print -P "Usage: %B$0%b [optionâ€¦] <input> <output>"
    echo "Options:"
    echo "    -d <file>  File to write dependencies to"
    echo "    -h         This message"
    exit 0
} elif [[ -z ${1:-} ]] {
    echo "Error: No input given"
    exit 2
} elif [[ -z ${2:-} ]] {
    echo "Error: No output given"
    exit 2
}
# ./sections/rst2zsh/main_logic.rst:27
typeset -U includes=()
# ./sections/rst2zsh/main_logic.rst:32
integer block_count=0
parse $1 $2
# ./sections/rst2zsh/main_logic.rst:46
[[ -n ${args[(I)-d]} ]] && echo $2: $0 $1 $includes >| ${args[-d]}
# ./sections/rst2zsh/main_logic.rst:53
:
